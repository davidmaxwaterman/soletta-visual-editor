/**
 *
 * @license
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * Authors:
 *   Elliot Smith <elliot.smith@intel.com>
 *   Max Waterman <max.waterman@intel.com>
 *
 **/
/*jshint -W002 */ // ignore warnings about "err" being overwritten in old IE
define(['lodash', 'js-signals', 'TypeMapper'], function (_, signals, TypeMapper) {
  'use strict';

  // keys which should never be overwritten in a node's metadata
  // as they are managed by NoFlo
  var RESERVED_META_KEYS = ['x', 'y', 'width', 'height', 'label'];

  // regexes for matching node IDs
  var nodeIdPattern = /^node(\d+)/;
  var nodeIdIncrementedPattern = /^(node\d+)_(\d+)/;

  // clone inports, outports or exports object whose "process"
  // property has the value <nodeId>;
  // returns an array
  // [{publicPort: <public port name>, port: <port object}, ...]
  // which can be used to reconstruct inports/outports/exports
  // via noflo.Graph.addOutport() etc.
  var clonePorts = function (ports) {
    var clones = [];
    var deepClone = true;

    _.each(ports, function (port, key) {
      var clone = _.clone(port, deepClone);
      clones.push({
        publicPort: key,
        port: clone
      });
    });

    return clones;
  };

  // add inports/outports/exports to the graph, using a cloned port
  // array as generated by clonePorts() (see above);
  // method is one of 'addOutport', 'addInport' or 'addExport';
  // portMap is an (optional) mapping from the name of a port on the original
  // node to the name of the port on the new node
  var addPorts = function (graph, method, ports, portMap) {
    for (var i = 0; i < ports.length; i++) {
      var originalPortName = ports[i].port;
      var portKey = (portMap ? portMap[originalPortName] : originalPortName);

      graph[method](
        ports[i].publicPort,
        ports[i].process,
        portKey,
        ports[i].metadata
      );
    }
  };

  /**
   * A class to wrap edit operations on a noflo Graph.
   * The reason for this is so that all edits are centralised into
   * a single object, so they can be correctly managed.
   */
  var GraphBuilder = function (options) {
    if (!(this instanceof GraphBuilder)) {
      return new GraphBuilder(options);
    }

    options = options || {};

    this.nodeId = 1;

    this.setLibrary(options.library);
    this.setGraph(options.graph);

    this.signals = {
      addIIPError: new signals.Signal(),
      removeIIPError: new signals.Signal(),
      nodeChangedError: new signals.Signal(),
      addNodeError: new signals.Signal(),
      addEdgeError: new signals.Signal(),
      componentChangedError: new signals.Signal(),

      // dispatched with the added node
      addNode: new signals.Signal(),

      // dispatched with the data, node ID and portName of the IIP
      addIIP: new signals.Signal(),

      // dispatched with the data, node ID, and portName of the IIP
      removeIIP: new signals.Signal(),

      // dispatched with the node which changed
      nodeChanged: new signals.Signal(),

      // dispatched with the ID of the removed node
      nodeRemoved: new signals.Signal(),

      // dispatched with the removed edge
      edgeRemoved: new signals.Signal(),

      // dispatched with old node ID, new node ID, new node which
      // replaced the existing node
      componentChanged: new signals.Signal(),

      // dispatched when nodes/edges are pasted into the graph;
      // dispatched with the pasted nodes, pasted edges
      pasted: new signals.Signal()
    };
  };

  GraphBuilder.prototype.dispatchAddNode = function (node) {
    this.signals.addNode.dispatch(node);
  };

  GraphBuilder.prototype.dispatchNodeChanged = function (node, oldMeta) {
    this.signals.nodeChanged.dispatch(node, oldMeta);
  };

  GraphBuilder.prototype.dispatchAddIIP = function (initializer) {
    this.signals.addIIP.dispatch(
      initializer.from.data,
      initializer.to.node,
      initializer.to.port
    );
  };

  GraphBuilder.prototype.dispatchRemoveIIP = function (initializer) {
    this.signals.removeIIP.dispatch(
      initializer.from.data,
      initializer.to.node,
      initializer.to.port
    );
  };

  /**
   * @param {ComponentLibrary} library
   */
  GraphBuilder.prototype.setLibrary = function (library) {
    if (!library) {
      this.library = null;
      return;
    }

    this.library = library;
  };

  /**
   * @param {slv.editor} editor
   */
  GraphBuilder.prototype.setEditor = function (editor) {
    this.editor = editor;
  };

  /**
   * @param {noflo.Graph} graph
   */
  GraphBuilder.prototype.setGraph = function (graph) {
    if (!graph) {
      this.graph = null;
      return;
    }

    if (this.graph) {
      this.graph.removeAllListeners('addNode');
      this.graph.removeAllListeners('changeNode');
      this.graph.removeAllListeners('addInitial');
      this.graph.removeAllListeners('removeInitial');
    }

    this.graph = graph;
    this.resetNodeIdCounter();

    this.graph.on('addNode', this.dispatchAddNode.bind(this));
    this.graph.on('changeNode', this.dispatchNodeChanged.bind(this));
    this.graph.on('addInitial', this.dispatchAddIIP.bind(this));
    this.graph.on('removeInitial', this.dispatchRemoveIIP.bind(this));
  };

  /**
   * Reset the automatic node ID generator.
   *
   * If there are no nodes in the graph, set it to 1.
   * If there are nodes, set it to the next integer after the
   * highest-numbered node; e.g. if "node21" is in the graph,
   * reset to counter to 22.
   */
  GraphBuilder.prototype.resetNodeIdCounter = function () {
    if (!this.graph || this.graph.nodes.length === 0) {
      this.nodeId = 1;
    }
    else {
      var nodeIds = _.pluck(this.graph.nodes, 'id');

      var idNumbers = _.reduce(nodeIds, function (memo, nodeId) {
        var matches = nodeIdPattern.exec(nodeId);
        if (matches) {
          memo.push(parseInt(matches[1], 10));
        }
        return memo;
      }, []);

      if (idNumbers.length > 0) {
        idNumbers = _.sortBy(idNumbers, function (idNumber) {
          return idNumber;
        });
        this.nodeId = _.last(idNumbers) + 1;
      }
      else {
        this.nodeId = 1;
      }
    }
  };

  /**
   * Get the next auto-generated node ID for the graph.
   *
   * @returns {string} next node ID
   */
  GraphBuilder.prototype.getNextNodeId = function () {
    var nodeId = 'node' + this.nodeId;
    this.nodeId += 1;
    return nodeId;
  };

  /**
   * Get the next auto-generated label for the graph. Note that
   * the labels in the graph include the label we're going to change
   * (this method is used to change node labels *just after* the node
   * has been pasted, at which point the node will still have a duplicate
   * label).
   *
   * @param {string} baseLabel    Label to base the new label on. If this
   * has a numeric suffix, e.g. "FOO1", the new label will have the
   * same prefix but increment the suffix, i.e. "FOO2". If the
   * base label has no suffix, the suffix is assumed to be "1";
   * e.g. if baseLabel == "FOO", this returns "FOO1" (unless "FOO1"
   * exists, in which case it returns "FOO2" etc.). If no
   * baseLabel is passed, "node" is assumed as the prefix and
   * "1" as the suffix. The suffix of the baseLabel is used to set a
   * minimum label counter; for example, if baseLabel is "node2" the
   * smallest label will be "node3", even if there is no "node1".
   *
   * @returns {string} next node label
   */
  GraphBuilder.prototype.getNextNodeLabel = function (baseLabel) {
    var baseLabelPrefix = 'node';
    var lowestNodeNumber = 0;
    var pattern;

    if (baseLabel) {
      pattern = new RegExp('^([^\\d]+)(\\d+)');

      // if the base label has a numeric suffix, get its value;
      // any candidate label has to have a suffix > this minimum value
      var baseLabelMatch = pattern.exec(baseLabel);

      if (baseLabelMatch) {
        // set the minimum number a node can have to one greater than
        // the suffix of the baseLabel
        lowestNodeNumber = parseInt(baseLabelMatch[2], 10);

        // reset baseLabel to just its prefix
        baseLabelPrefix = baseLabelMatch[1];
      }
      else {
        baseLabelPrefix = baseLabel;
      }
    }
    else {
      baseLabel = baseLabelPrefix;
    }

    // now we have the base label prefix, we look for node labels matching
    // that followed by a numeric suffix
    pattern = new RegExp('^' + baseLabelPrefix + '(\\d+)');

    // get the "N" part of all the labels which are in the form
    // "<baseLabelPrefix>N"
    var nodeNumbers = _.reduce(this.graph.nodes, function (memo, node) {
      var matches = pattern.exec(node.metadata.label);

      // exclude the base label which was passed in
      if (matches && matches[1] && node.metadata.label !== baseLabel) {
        var num = parseInt(matches[1], 10);

        // we're only interested in node numbers greater than our minimum
        if (num > lowestNodeNumber) {
          memo.push(num);
        }
      }

      return memo;
    }, []);

    var candidate;

    // add our lowestNodeNumber to the list of candidate numbers
    nodeNumbers.unshift(lowestNodeNumber);

    // numeric sort
    nodeNumbers.sort(function (a, b) {
      return a - b;
    });

    // loop through the list, looking for a gap in it
    for (var i = 0; i < nodeNumbers.length; i++) {
      candidate = nodeNumbers[i] + 1;

      if (i < (nodeNumbers.length - 1) && candidate !== nodeNumbers[i + 1]) {
        break;
      }
    }

    return baseLabelPrefix + candidate;
  };

  /**
   * Create a new node ID without incrementing the node counter;
   * used to create copies of existing nodes (e.g. via
   * changeComponent()).
   *
   * @returns {string} sub node ID
   */
  GraphBuilder.prototype.getSubNodeId = function (nodeId) {
    // node ID already has a suffix
    var matches = nodeIdIncrementedPattern.exec(nodeId);

    if (matches) {
      nodeId = matches[1];
      var counter = parseInt(matches[2], 10) + 1;
      return nodeId + '_' + counter;
    }
    else {
      return nodeId + '_1';
    }
  };

  /**
   * Merge member variables <members> with the metadata of the node
   * identified by ID <nodeId>. Note that if the node already has
   * metadata whose names match names in <members>, the values for
   * those properties will be overwritten.
   *
   * @param {string} nodeId    ID of node to set member data for
   * @param {string} nodeLabel    Label for node; NB this will be
   * included in the metadata set on the node as the "label" property
   * @param {object} members    Name/value pairs to set as member
   * variable values on node; note that there's no validation of
   * names in <members> against the component: if <members> contains a
   * name which doesn't correspond to a member variable on the node's
   * component, it will still get set; also note that values in
   * members will overwrite any values in the node's existing metadata,
   * except for x, y, width and height (see RESERVED_META_KEYS)
   * @param {object} options force to ignore RESERVED_META_KEYS, to allow seting x and y
   */
  GraphBuilder.prototype.setMetadata = function (nodeId, nodeLabel, members, options) {
    var node = this.graph.getNode(nodeId);
    options = _.defaults(options||{}, { force: false });

    if (!node) {
      var err = new Error('unable to change node with ID ' + nodeId +
                          ' as it does not exist in the graph');
      this.signals.nodeChangedError.dispatch(err);
      return;
    }

    var deepClone = true;
    var metadata = _.clone(node.metadata, deepClone);

    _.each(members, function (value, name) {
      if (options.force || !_.includes(RESERVED_META_KEYS, name)) {
        metadata[name] = value;
      }
    });

    metadata.label = nodeLabel;

    this.graph.setNodeMetadata(nodeId, metadata);
  };

  /**
   * Move nodes in a given direction
   */
  GraphBuilder.prototype.moveNodes = function (nodes, direction) {
    var self = this;
    var unit = 10;
    var ddx = 0;
    var ddy = 0;

    if (direction === 'up' || direction === 'down') {
      ddy = unit;
    } else {
      ddx = unit;
    }

    if (direction === 'up' || direction === 'left') {
      ddy = -ddy;
      ddx = -ddx;
    }

    var scale = this.editor.getScale();
    var deltaX = Math.round( ddx / scale );
    var deltaY = Math.round( ddy / scale );

    nodes.forEach(function (thisNode) {
      // move nodes
      var position = {
        x: thisNode.metadata.x,
        y: thisNode.metadata.y
      };

      position.x += deltaX;
      position.y += deltaY;

      self.setMetadata(thisNode.id, thisNode.metadata.label, position, {force: true});
    });
  };

  /**
   * Add an IIP for the inport on a node. Note that this will remove
   * any existing IIPs for that inport on that node (the assumption
   * being you only want one IIP on an inport).
   *
   * @param {any} data    Value for the IIP
   * @param {string} nodeId    ID of the node to add the IIP to
   * @param {string} portName    Name of the inport on the node
   */
  GraphBuilder.prototype.addIIP = function (data, nodeId, portName) {
    var self = this;

    this.removeIIP(nodeId, portName);

    var metadata = {};

    setTimeout(function () {
      self.graph.addInitial(data, nodeId, portName, metadata);
    }, 0);
  };

  /**
   * Remove the IIP for node with ID <nodeId> and port <portName>.
   *
   * @param {string} nodeId    ID of node to remove IIP from
   * @param {string} portName    Name of port on node
   */
  GraphBuilder.prototype.removeIIP = function (nodeId, portName) {
    if (!this.graph) {
      var err = new Error('ensure graph is initialised before calling removeIIP()');
      this.signals.removeIIPError.dispatch(err);
      return;
    }

    this.graph.removeInitial(nodeId, portName);
  };

  /**
   * Copy the content of <clipboard> into the graph.
   * This is done here so that it can be correctly wrapped
   * for undo/redo (it modifies the graph, so it should go
   * through GraphBuilder).
   *
   * @param {TheGraph.Clipboard} clipboard    Instance of TheGraph
   * Clipboard; this is populated with the nodes to be pasted
   * in the-graph-editor
   * nodes; array of nodes to copy
   */
  GraphBuilder.prototype.copy = function (clipboard, nodes) {
    clipboard.copy(this.graph, nodes);
  };

  GraphBuilder.prototype.del = function (nodes, edges) {
    var self = this;
    nodes.forEach(function (node) {
      self._removeNode(node.id);
    });
    edges.forEach(function (edge) {
      self._removeEdge(
        edge.from.node,
        edge.from.port,
        edge.to.node,
        edge.to.port);
    });
  };

  /**
   * Paste the content of <clipboard> into the graph.
   * This is done here so that it can be correctly wrapped
   * for undo/redo (it modifies the graph, so it should go
   * through GraphBuilder).
   *
   * @param {TheGraph.Clipboard} clipboard    Instance of TheGraph
   * Clipboard; this is populated with the nodes to be pasted
   * in the-graph-editor
   * options:
   *   autoposition: automatically rename and position the node to
   *                 a position near the top left of the viewport.
   *                 (used for pasting nodes copied into the clipboard)
   */
  GraphBuilder.prototype.paste = function (clipboard, options) {
    options = options || { autoposition: false };

    var pasted = clipboard.paste(this.graph);
    var numPasted = pasted.length;

    if (options.autoposition) {
      var self = this;

      // all nodes move by the same delta as the top left one, which
      // is placed where the context menu is
      var delta = {
        x: 0,
        y: 0
      };

      var findTopLeftNode = function (nodes) {
        // to start with, assume topLeft is first node
        var topLeft = {
          x: nodes[0].metadata.x,
          y: nodes[0].metadata.y
        };

        // skip first one
        for (var i = 1; i < numPasted; i++) {
          var node = nodes[i];

          if (node.metadata.y < topLeft.y && node.metadata.x < topLeft.x) {
            topLeft = {
              x: node.metadata.x,
              y: node.metadata.y
            };
          }
        }

        return topLeft;
      };

      if (options.position) {
        var topLeft = findTopLeftNode(pasted.nodes);

        // constant offset that is applied to pasted nodes in
        // the-graph/the-graph-clipboard.js:paste() and needs to be removed
        var pastedOffset = {
          x: 36,
          y: 36
        };

        // calculate delta between top left and options.position
        // so the 'arrangement' of the copied nodes can be maintained
        // and all nodes moved by the same delta
        // also remove pastedOffset
        delta.x = options.position.x - topLeft.x + pastedOffset.x;
        delta.y = options.position.y - topLeft.y + pastedOffset.y;
      }

      pasted.nodes.forEach(function (node) {
        var newPosition = {};

        if (options.position) {
          // remove width/height too, so it is directly over the context menu
          newPosition.x = node.metadata.x + delta.x - node.metadata.width;
          newPosition.y = node.metadata.y + delta.y - node.metadata.height;
        }
        else {
          // position pasted at top left of viewport
          newPosition = self.editor.getNodePosition(node.component);
        }

        var newLabel = self.getNextNodeLabel(node.metadata.label);

        self._setMetadata(node.id, newLabel, newPosition, { force: true });
      });
    }

    this.signals.pasted.dispatch(pasted.nodes, pasted.edges);
  };

  /**
   * Remove the node with ID nodeId from the graph.
   *
   * @param {string} nodeId    ID of node to remove
   */
  GraphBuilder.prototype.removeNode = function (nodeId) {
    var self = this;
    this.graph.removeNode(nodeId);
    setTimeout(function () {
      self.signals.nodeRemoved.dispatch(nodeId);
    }, 0);
  };

  /**
   * Remove the edge from fromNodeId+fromPort to
   * toNodeId+toPort.
   */
  GraphBuilder.prototype.removeEdge = function (fromNodeId, fromPortName,
      toNodeId, toPortName) {
    var self = this;
    this.graph.removeEdge(fromNodeId, fromPortName, toNodeId, toPortName);
    setTimeout(function () {
      self.signals.edgeRemoved.dispatch({
        to: {
          node: toNodeId,
          port: toPortName
        },

        from: {
          node: fromNodeId,
          port: fromPortName
        }
      });
    }, 0);
  };

  /**
   * Add a node of type componentName to the graph.
   *
   * @param {string} componentName    Name of a component known
   * to the wrapped editor's library (this.$.editor.$.graph.library)
   * @param {object} metadata    Metadata specification to set
   * x, y, width, height and label for the node; if not set,
   * defaults to a random position
   * @param {string} [nodeId=generated ID]    ID of the node to add;
   * if not set, defaults to 'nodeN', where N is a self-incrementing
   * counter
   *
   * @dispatches Error on this.signals.addNodeError if the component
   * name is not known or there is an error when adding the node
   * to the wrapped NoFlo graph.
   *
   * @returns {string} The ID of the created node
   */
  GraphBuilder.prototype.addNode = function (componentName, metadata, nodeId) {
    var err;

    var component = this.library.get(componentName);

    if (!this.graph) {
      err = new Error('ensure graph is initialised before calling addNode()');
    }
    else if (!component) {
      err = new Error('cannot add node of type ' + componentName +
                      ' to graph as type is not defined in the library');
    }

    // early return on error
    if (err) {
      this.signals.addNodeError.dispatch(err);
      return;
    }

    if (!nodeId) {
      nodeId = this.getNextNodeId();
    }

    metadata = metadata || {};
    metadata.label = metadata.label || this.getNextNodeLabel();

    // add default members for the component
    metadata = _.extend(metadata, component.getDefaultMembers());

    // the setTimeout ensures the wrapped editor component
    // has properly initialised before we attempt to add nodes to it
    try {
      this.graph.addNode(
        nodeId, // node IDs have to be strings
        componentName,
        metadata
      );
    }
    catch (err) {
      this.signals.addNodeError.dispatch(err);
    }

    return nodeId;
  };

  /**
   * Add an edge between two nodes.
   *
   * @param {string} fromNode    ID of source node
   * @param {string} fromNodePort    Name of port on source node
   * @param {string} toNode    ID of target node
   * @param {string} toNodePort    Name of port on target node
   *
   * @dispatches Error on this.signals.addEdgeError if error
   * occurs when adding node to wrapped NoFlo graph.
   */
  GraphBuilder.prototype.addEdge = function (fromNode, fromNodePort,
      toNode, toNodePort, metadata) {
    var err;

    if (!this.graph) {
      err = new Error('ensure graph is initialised before calling addEdge()');
    }

    // early return on error
    if (err) {
      this.signals.addEdgeError.dispatch(err);
      return;
    }

    metadata = metadata || {};

    try {
      this.graph.addEdge(
        fromNode,
        fromNodePort,
        toNode,
        toNodePort,
        metadata
      );
    }
    catch (err) {
      this.signals.addEdgeError.dispatch(err);
    }
  };

  /**
   * Replace the node identified by nodeId, but as an instance of the
   * component <Component>. The node's metadata is copied over to the
   * new node, so it will have the same dimensions and position as the
   * original. Any edges from/to the original node are also recreated,
   * attached to the new node. Groups/initializers etc. are also
   * reconstructed (the code in noflo.Graph.renameNode() was used
   * as a basis for this method).
   *
   * The ports on the original node are matched to ports on the
   * component being used to create the replacement, and connected the
   * same way those ports were. If the ports are incorrect on the
   * new component, an error will be dispatched.
   *
   * @param {string} nodeId    ID of the node to replace
   * @param {string} component    Component to use as the basis for
   * the new node; it should have inports/outports whose types match the
   * ones on the Component of the node identified by nodeId
   */
  GraphBuilder.prototype.changeComponent = function (nodeId, component) {
    var self = this;

    var err;
    var node;
    var portMap;

    if (!this.graph) {
      err = new Error('ensure graph is initialised before calling ' +
                      'changeComponent()');
    }

    if (!this.library) {
      err = new Error('ensure library is initialised before calling ' +
                      'changeComponent()');
    }

    if (!err) {
      node = this.graph.getNode(nodeId);

      if (!node) {
        err = new Error('node with ID ' + nodeId + ' does not exist');
      }
    }

    if (!err) {
      var originalComponent = this.library.get(node.component);
      portMap = this.library.mapPorts(originalComponent, component);

      if (!portMap) {
        err = new Error('could not map ports from ' + node.component +
                        ' to ' + component.name);
      }
    }

    // early return on error
    if (err) {
      console.error(err);
      this.signals.componentChangedError.dispatch(err);
      return;
    }

    // remove any keys which aren't in the reserved meta keys list
    // (i.e. any meta which belongs to the old component which we're
    // replacing)
    var deepClone = true;
    var metadata = _.reduce(node.metadata, function (memo, value, key) {
      if (_.includes(RESERVED_META_KEYS, key)) {
        memo[key] = _.clone(value, deepClone);
      }
      return memo;
    }, {});

    // clone edges
    var edges = [];
    var edge;
    for (var i = 0; i < this.graph.edges.length; i++) {
      edge = this.graph.edges[i];
      if (edge.from.node === nodeId || edge.to.node === nodeId) {
        edges.push(_.clone(edge, deepClone));
      }
    }

    // clone initializers
    var iips = [];
    for (i = 0; i < this.graph.initializers.length; i++) {
      if (this.graph.initializers[i].to.node === nodeId) {
        iips.push(_.clone(this.graph.initializers[i], deepClone));
      }
    }

    // clone inports
    var inports = clonePorts(this.graph.inports);

    // clone outports
    var outports = clonePorts(this.graph.outports);

    // clone exports
    var exports = clonePorts(this.graph.exports);

    // keep references to groups containing the node
    var groups = [];
    var index;
    for (i = 0; i < this.graph.groups.length; i++) {
      index = this.graph.groups[i].nodes.indexOf(nodeId);
      if (index !== -1) {
        groups.push(this.graph.groups[i]);
      }
    }

    this.graph.once('endTransaction', function () {
      var newNodeId = self.getSubNodeId(nodeId);

      // reconstruct the node from the clones
      self.addNode(component.name, metadata, newNodeId);

      for (i = 0; i < edges.length; i++) {
        var fromNode;
        var fromPort;
        var toNode;
        var toPort;

        // map the port names on the original node to
        // the corresponding port names on the new node (for cases
        // where the names differ)
        if (edges[i].from.node === nodeId) {
          fromNode = newNodeId;
          fromPort = portMap.outports[edges[i].from.port];
          toNode = edges[i].to.node;
          toPort = edges[i].to.port;
        }
        else if (edges[i].to.node === nodeId) {
          fromNode = edges[i].from.node;
          fromPort = edges[i].from.port;
          toNode = newNodeId;
          toPort = portMap.inports[edges[i].to.port];
        }

        self.addEdge(
          fromNode,
          fromPort,
          toNode,
          toPort,
          edges[i].metadata
        );
      }

      for (i = 0; i < iips.length; i++) {
        var iip = iips[i];

        // the port into which iips for this node enter must be mapped
        // to the port name on the new component type
        self.graph.addInitial(
          iip.from.data,
          newNodeId,
          portMap.inports[iip.to.port],
          iip.metadata
        );
      }

      addPorts(self.graph, 'addInport', newNodeId, inports, portMap.inports);
      addPorts(self.graph, 'addOutport', newNodeId, outports, portMap.outports);
      addPorts(self.graph, 'addExport', newNodeId, exports);

      for (i = 0; i < groups.length; i++) {
        groups[i].nodes.push(newNodeId);
      }

      setTimeout(function () {
        self.signals.componentChanged.dispatch(
          nodeId,
          newNodeId,
          self.graph.getNode(newNodeId)
        );
      }, 0);
    });

    // remove the existing node
    this.graph.removeNode(nodeId);
  };

  /**
   * Extracts all the member variables from a raw 'FBP' file
   * into an object with keys of nodeId.
   */
  GraphBuilder.prototype.extractAllMembers = function (rawFbp) {
    var self = this;
    var allMembers = {}; // collect all member variables

    var extractNodes = function (rawFbp) {
      var nodes = [];
      var lines = rawFbp.split(/\n/);
      lines.forEach(function (line) {
        // ignore comments and blank lines
        if (line.match(/^#/) || line.match(/^$/)) {
          return;
        }

        var theseNodes = line.split(/\s*\w+(?:\[\d+\])*\s*->\s*\w+(?:\[\d+\])*\s*/);
        theseNodes.forEach(function (node) {
          if (node) {
            nodes.push(node);
          }
        });
      });

      return nodes;
    };

    extractNodes(rawFbp).forEach(function (node) {

      // extract bits of each node's definition
      var matches = node.match(/^([^(]+)(\(([^:)]+):*([^)]*|(?:[^"]+"[^"]*")*)\))?$/);
      var nodeId = matches[1];
      var componentName = matches[3];
      var namedObject = self.library.get(componentName);
      var componentsMembers = namedObject?namedObject.members:undefined;

      // "label=node3,true_range=max:255|min:1|step:0|val:128"
      var thisNodesMembers = matches.pop(); // some nodes are only nodeId
      if (thisNodesMembers) {
        var theseMembers = {};

        // ["label=node3","true_range=max:255|min:1|step:0|val:128"]
        var kvps = thisNodesMembers.split(',');
        kvps.forEach(function (kvp) {
          // ["true_range","max:255|min:1|step:0|val:128"]
          var bits = kvp.split('=');
          if (bits[0] !== 'label') {
            // {"max":"255","min":"1","step":"0","val":"128"}
            var membersObject;
            var type = _.result(_.find(componentsMembers, {'name': bits[0]}), 'type');

            bits[1].split('|').forEach(function (pair) {
              // ["max","255"] or "false"
              var subBits = pair.split(':');
              if (subBits.length===1) {
                membersObject = TypeMapper.convertType(subBits[0], type);
              } else {
                membersObject = membersObject || {};
                membersObject[subBits[0]] = TypeMapper.convertType(subBits[1], type);
              }
            });

            // "true_range": { "max":"255","min":"1","step":"0","val":"128"}
            theseMembers[bits[0]] = membersObject;
          }
        });

        if (Object.keys(theseMembers).length) {
          /*
          {
            "node1": {
              "true_range": { "max":"255","min":"1","step":"0","val":"128"},
              ...
            },
            ...
          }
          */
          allMembers[nodeId] = theseMembers;
        }
      }
    });

    return allMembers;
  };

  /**
   * Moves node declarations to their first use in the fbp
   */
  GraphBuilder.prototype.moveNodeDeclarations = function (rawFbp) {
    var lines = rawFbp.split('\n');

    // first extract the declarations
    var declarations = [];

    lines.forEach(function (line) {
      var matches = line.match(/^(\w+(\([^)]*|(?:[^"]+"[^"]*")*)\))$/);
      if (matches && matches[1]) {
        declarations.push(matches[1]);
      }
    });

    declarations.forEach(function (declaration) {
      // then remove the declaration from rawFbp
      var escapedDeclaration = declaration.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      var declarationRegExp = '^\\s*'+escapedDeclaration+'\\s*$';
      rawFbp = rawFbp.replace(new RegExp(declarationRegExp, 'm'),'');
    });

    declarations.forEach(function (declaration) {
      // and replace the first occurance with the declaration
      var nodeId = declaration.match(/^([^(]+)/)[0];
      rawFbp = rawFbp.replace(nodeId,declaration);
    });

    rawFbp = rawFbp.replace(/^(?:\s*|#.*)[\r\n]/gm,'');

    return rawFbp;
  };

  /**
   * Rename anomymous nodes
   */
  GraphBuilder.prototype.renameAnonymousNodes = function (fbp) {
    var anonIndex = 1;
    while (fbp.indexOf('_(') !== -1) {
      fbp = fbp.replace('_(','anon'+anonIndex+'(');

      anonIndex++;
    }

    return fbp;
  };

  /**
   * Sets the member variables in the nofloGraph as stored in allMembers.
   */
  GraphBuilder.prototype.setAllNodeMetadata = function (nofloGraph, allMembers) {
    Object.keys(allMembers).forEach(function (key) {
      var nodeId = key;
      var metadata = allMembers[key];
      nofloGraph.setNodeMetadata(nodeId, metadata);
    });
  };

  return GraphBuilder;
});
